'use strict';

exports.__esModule = true;
exports.BaseApi = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _http = require('../utils/http');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Authentication credentials - an app token or a JWT must be provided
 * @typedef AuthCredentials
 * @type {object}
 * @property {string} [appToken] - an app token
 * @property {string} [jwt] - a JWT generated with the app secret and key id
 */

/**
 * @class BaseApi
 */

var BaseApi = exports.BaseApi = function () {
  function BaseApi(serviceUrl, authHeaders) {
    (0, _classCallCheck3.default)(this, BaseApi);

    this.serviceUrl = serviceUrl;
    this.authHeaders = authHeaders;

    // both are allowed unless stated otherwise
    this.allowedAuth = ['jwt', 'appToken'];
  }

  /**
   * Build an URL from fragments to call the API
   * @return {string} - an URL
   */

  BaseApi.prototype.getFullURL = function getFullURL() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var fragments = args.map(function (fragment) {
      return encodeURIComponent(fragment);
    });
    return _http.urljoin.apply(undefined, [this.serviceUrl].concat(fragments));
  };

  /**
   * Validates the headers sent to the server
   * @param  {array} allowedAuth  - an array of allowedAuth to override the ones on the instance
   * @return {object}             - the headers object passed in parameter
   */

  BaseApi.prototype.validateAuthHeaders = function validateAuthHeaders() {
    var allowedAuth = arguments.length <= 0 || arguments[0] === undefined ? this.allowedAuth : arguments[0];

    if (!allowedAuth || allowedAuth.length === 0) {
      return _promise2.default.reject(new Error('Must at least provide one authentication method.'));
    }

    if (!this.authHeaders) {
      return _promise2.default.reject(new Error('Must provide headers.'));
    }

    var canContainJwt = allowedAuth.indexOf('jwt') >= 0;
    var canContainToken = allowedAuth.indexOf('appToken') >= 0;

    var hasJwt = !!this.authHeaders.Authorization;
    var hasToken = !!this.authHeaders['app-token'];

    if (!canContainJwt && hasJwt) {
      return _promise2.default.reject(new Error('Must not use JWT for authentication.'));
    }

    if (!canContainToken && hasToken) {
      return _promise2.default.reject(new Error('Must not use an app token for authentication.'));
    }

    return _promise2.default.resolve(this.authHeaders);
  };

  return BaseApi;
}();